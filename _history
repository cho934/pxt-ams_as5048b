{"entries":[{"timestamp":1744219162030,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" x=\"20\" y=\"20"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start"],[0,"\"></"]],"start1":12,"start2":12,"length1":111,"length2":62},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"pe=\""],[-1,"function_definition\" x=\"225\" y=\"20\"><mutation name=\"test\" functionid=\"X=9%Fn=zKCpZUSk,q7O4\"></mutation><field name=\"function_name\">test</field"],[1,"device_forever\""],[0,"></b"]],"start1":92,"start2":92,"length1":150,"length2":23},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n\t\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":33,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   \""],[-1,"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":239,"start2":239,"length1":32,"length2":31}]}]},{"timestamp":1744219303881,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"/**\n * AS5048B Magnetic Rotary Encoder driver for MicroBit\n */\n\n//% color=#0fbc11 icon=\"\\uf085\" block=\"AS5048B\"\nnamespace AS5048B {\n    // Constants for register addresses\n    const REG_PROG = 0x03;          // Programming register\n    const REG_ADDR = 0x15;          // Address register\n    const REG_ZEROMSB = 0x16;       // Zero position MSB register\n    const REG_ZEROLSB = 0x17;       // Zero position LSB register\n    const REG_AGC = 0xFA;           // Automatic Gain Control register\n    const REG_DIAG = 0xFB;          // Diagnostics register\n    const REG_MAGNMSB = 0xFC;       // Magnitude MSB register\n    const REG_MAGNLSB = 0xFD;       // Magnitude LSB register\n    const REG_ANGLMSB = 0xFE;       // Angle MSB register\n    const REG_ANGLLSB = 0xFF;       // Angle LSB register\n\n    // Masks and constants\n    const ANGLE_MASK = 0x3FFF;      // 14-bit mask for angle value\n    const RESOLUTION = 16384;       // 2^14, maximum value for angle\n\n    // Angle unit constants\n    const U_RAW = 1;                // Raw sensor value (0-16383)\n    const U_TRN = 2;                // Turn (0.0-1.0)\n    const U_DEG = 3;                // Degrees (0.0-359.98)\n    const U_RAD = 4;                // Radians (0.0-6.28)\n    const U_GRAD = 5;               // Gradians (0.0-400.0)\n\n    /**\n     * Calculate the I2C address based on a1 and a2 pins\n     * Equivalent to: #define AS5048B_ADDR(a1,a2)  (uint8_t)(0x40 | ( !a1 ? 0x2 : 0 ) | ( !a2 ? 0x1 : 0 ))\n     * @param a1 Address pin A1 state\n     * @param a2 Address pin A2 state\n     * @returns Calculated I2C address\n     */\n    function calculateAddress(a1: number, a2: number): number {\n        return 0x40 | (!a1 ? 0x2 : 0) | (!a2 ? 0x1 : 0);\n    }\n\n    /**\n     * Creates a new AS5048B sensor instance\n     * @param a1 State of A1 address pin (0 or 1)\n     * @param a2 State of A2 address pin (0 or 1)\n     */\n    //% blockId=as5048b_create_with_pins block=\"créer capteur AS5048B avec pins a1 %a1 a2 %a2\"\n    //% a1.defl=1\n    //% a2.defl=1\n    //% weight=100\n    export function createSensorWithPins(a1: number = 1, a2: number = 1): AS5048BSensor {\n        const address = calculateAddress(a1, a2);\n        return new AS5048BSensor(address);\n    }\n\n    /**\n     * Creates a new AS5048B sensor instance\n     * @param address I2C address of the sensor (default: 0x40)\n     */\n    //% blockId=as5048b_create block=\"créer capteur AS5048B à l'adresse %address\"\n    //% address.defl=0x40\n    //% weight=99\n    export function createSensor(address: number = 0x40): AS5048BSensor {\n        return new AS5048BSensor(address);\n    }\n\n    /**\n     * Class representing an AS5048B magnetic rotary encoder\n     */\n    export class AS5048BSensor {\n        private i2cAddr: number;\n        private clockWise: boolean;\n        private lastAngleRaw: number;\n\n        // Moving average variables\n        private movingAvgEnabled: boolean;\n        private movingAvgAlpha: number;\n        private movingAvgSin: number;\n        private movingAvgCos: number;\n        private movingAvgAngle: number;\n        private movingAvgCount: number;\n        private readonly INIT_AVG_COUNT = 5;\n\n        /**\n         * Create a new AS5048B sensor\n         * @param address I2C address of the sensor\n         */\n        constructor(address: number) {\n            this.i2cAddr = address;\n            this.clockWise = false;\n            this.lastAngleRaw = 0;\n\n            // Initialize moving average variables\n            this.movingAvgEnabled = false;\n            this.movingAvgAlpha = 0.2;\n            this.movingAvgSin = 0;\n            this.movingAvgCos = 0;\n            this.movingAvgAngle = 0;\n            this.movingAvgCount = 0;\n        }\n\n        // Rest of the class implementation remains unchanged\n\n        /**\n         * Set the I2C address for this sensor\n         * @param address New I2C address\n         */\n        //% blockId=as5048b_set_address block=\"%sensor|définir l'adresse I2C à %address\"\n        //% weight=90\n        setAddress(address: number): void {\n            this.i2cAddr = address;\n        }\n\n        /**\n         * Set rotation direction (clockwise or counter-clockwise)\n         * @param cw true for clockwise, false for counter-clockwise\n         */\n        //% blockId=as5048b_set_direction block=\"%sensor|définir direction %cw\"\n        //% cw.defl=false\n        //% weight=85\n        setClockWise(cw: boolean): void {\n            this.clockWise = cw;\n            this.resetMovingAvg();\n        }\n\n        /**\n         * Check if the sensor is connected\n         * @returns true if connected, false otherwise\n         */\n        //% blockId=as5048b_is_connected block=\"%sensor|est connecté ?\"\n        //% weight=80\n        isConnected(): boolean {\n            try {\n                // Read angle register to check connection\n                pins.i2cWriteNumber(this.i2cAddr, REG_ANGLMSB, NumberFormat.UInt8BE);\n                const result = pins.i2cReadNumber(this.i2cAddr, NumberFormat.UInt16BE);\n                return true; // If we get here, communication worked\n            } catch (e) {\n                return false;\n            }\n        }\n\n        /**\n         * Read register value (8-bit)\n         * @param reg Register address\n         * @returns 8-bit register value\n         */\n        private readReg8(reg: number): number {\n            pins.i2cWriteNumber(this.i2cAddr, reg, NumberFormat.UInt8BE);\n            return pins.i2cReadNumber(this.i2cAddr, NumberFormat.UInt8BE);\n        }\n\n        /**\n         * Read register value (16-bit)\n         * @param reg Register address\n         * @returns 14-bit register value (masked appropriately)\n         */\n        private readReg16(reg: number): number {\n            pins.i2cWriteNumber(this.i2cAddr, reg, NumberFormat.UInt8BE);\n            const value = pins.i2cReadNumber(this.i2cAddr, NumberFormat.UInt16BE);\n            return value & ANGLE_MASK; // Mask to 14 bits\n        }\n\n        /**\n         * Write register value (8-bit)\n         * @param reg Register address\n         * @param value Value to write\n         */\n        private writeReg(reg: number, value: number): void {\n            pins.i2cWriteRegister(this.i2cAddr, reg, value);\n        }\n\n        /**\n         * Get the raw angle value (0-16383)\n         * @returns Raw angle value (14-bit)\n         */\n        //% blockId=as5048b_raw_angle block=\"%sensor|angle brut\"\n        //% weight=75\n        getRawAngle(): number {\n            let rawValue = this.readReg16(REG_ANGLMSB);\n\n            // Handle clockwise rotation if needed\n            if (this.clockWise) {\n                rawValue = ANGLE_MASK - rawValue;\n            }\n\n            this.lastAngleRaw = rawValue;\n            return rawValue;\n        }\n\n        /**\n         * Get the angle in degrees (0-359.98)\n         * @returns Angle in degrees\n         */\n        //% blockId=as5048b_angle_deg block=\"%sensor|angle en degrés\"\n        //% weight=70\n        getAngle(): number {\n            return this.convertAngle(U_DEG, this.getRawAngle());\n        }\n\n        /**\n         * Get the angle in radians (0-6.28)\n         * @returns Angle in radians\n         */\n        //% blockId=as5048b_angle_rad block=\"%sensor|angle en radians\"\n        //% weight=65\n        getAngleRad(): number {\n            return this.convertAngle(U_RAD, this.getRawAngle());\n        }\n\n        /**\n         * Convert raw angle to specified unit\n         * @param unit Unit to convert to (U_RAW, U_TRN, U_DEG, U_RAD, U_GRAD)\n         * @param angle Raw angle value\n         * @returns Converted angle value\n         */\n        private convertAngle(unit: number, angle: number): number {\n            switch (unit) {\n                case U_RAW:\n                    return angle;\n                case U_TRN:\n                    return angle / RESOLUTION;\n                case U_DEG:\n                    return (angle * 360) / RESOLUTION;\n                case U_RAD:\n                    return (angle * 2 * Math.PI) / RESOLUTION;\n                case U_GRAD:\n                    return (angle * 400) / RESOLUTION;\n                default:\n                    return angle;\n            }\n        }\n\n        /**\n         * Get the Automatic Gain Control value\n         * @returns AGC value (0-255)\n         */\n        //% blockId=as5048b_get_agc block=\"%sensor|valeur AGC\"\n        //% weight=60\n        getAgc(): number {\n            return this.readReg8(REG_AGC);\n        }\n\n        /**\n         * Program the current position as the zero position\n         */\n        //% blockId=as5048b_program_zero block=\"%sensor|programmer position zéro\"\n        //% weight=55\n        programZeroPosition(): void {\n            // First write 0 to zero register\n            this.zeroRegisterWrite(0);\n            // Then read current angle and set it as zero position\n            const newZero = this.readReg16(REG_ANGLMSB);\n            this.zeroRegisterWrite(newZero);\n        }\n\n        /**\n         * Write value to zero position register\n         * @param value Zero position value\n         */\n        private zeroRegisterWrite(value: number): void {\n            this.writeReg(REG_ZEROMSB, (value >> 6) & 0xFF);\n            this.writeReg(REG_ZEROLSB, value & 0x3F);\n        }\n\n        /**\n         * Read zero position register\n         * @returns Zero position value\n         */\n        //% blockId=as5048b_read_zero_reg block=\"%sensor|lire registre zéro\"\n        //% weight=50\n        zeroRegisterRead(): number {\n            return this.readReg16(REG_ZEROMSB);\n        }\n\n        /**\n         * Get the diagnostic value\n         * @returns Diagnostic register value\n         */\n        //% blockId=as5048b_get_diag block=\"%sensor|valeur diagnostic\"\n        //% weight=45\n        getDiagnostic(): number {\n            return this.readReg8(REG_DIAG);\n        }\n\n        /**\n         * Get the magnitude value of the magnetic field\n         * @returns Magnitude value\n         */\n        //% blockId=as5048b_get_magnitude block=\"%sensor|valeur magnitude\"\n        //% weight=40\n        getMagnitude(): number {\n            return this.readReg16(REG_MAGNMSB);\n        }\n\n        /**\n         * Check if there is a CORDIC overflow error\n         * @returns true if CORDIC overflow error is present\n         */\n        //% blockId=as5048b_diag_cordic block=\"%sensor|cordic overflow ?\"\n        //% weight=35\n        hasCordicOverflow(): boolean {\n            const diag = this.getDiagnostic();\n            return (diag & 0x0001) !== 0;\n        }\n\n        /**\n         * Check if the magnet is too strong\n         * @returns true if magnet is too strong\n         */\n        //% blockId=as5048b_diag_mag_high block=\"%sensor|aimant trop fort ?\"\n        //% weight=30\n        isMagnetTooStrong(): boolean {\n            const diag = this.getDiagnostic();\n            return (diag & 0x0008) !== 0;\n        }\n\n        /**\n         * Check if the magnet is too weak\n         * @returns true if magnet is too weak\n         */\n        //% blockId=as5048b_diag_mag_low block=\"%sensor|aimant trop faible ?\"\n        //% weight=25\n        isMagnetTooWeak(): boolean {\n            const diag = this.getDiagnostic();\n            return (diag & 0x0004) !== 0;\n        }\n\n        /**\n         * Enable exponential moving average filtering\n         * @param enable true to enable, false to disable\n         * @param alpha Smoothing factor (0.0-1.0)\n         */\n        //% blockId=as5048b_enable_moving_avg block=\"%sensor|activer moyenne mobile %enable || alpha %alpha\"\n        //% enable.defl=true\n        //% alpha.defl=0.2\n        //% expandableArgumentMode=\"toggle\"\n        //% weight=20\n        enableMovingAvg(enable: boolean, alpha: number = 0.2): void {\n            this.movingAvgEnabled = enable;\n            this.movingAvgAlpha = alpha < 0 ? 0 : (alpha > 1 ? 1 : alpha);\n            this.resetMovingAvg();\n        }\n\n        /**\n         * Reset moving average calculations\n         */\n        private resetMovingAvg(): void {\n            this.movingAvgCount = 0;\n            this.movingAvgSin = 0;\n            this.movingAvgCos = 0;\n            this.movingAvgAngle = 0;\n        }\n\n        /**\n         * Update the exponential moving average\n         * Should be called regularly to maintain accurate averaging\n         */\n        //% blockId=as5048b_update_moving_avg block=\"%sensor|mettre à jour moyenne mobile\"\n        //% weight=15\n        updateMovingAvg(): void {\n            if (!this.movingAvgEnabled) return;\n\n            // Get angle in radians\n            const angle = this.getAngleRad();\n            const sin = Math.sin(angle);\n            const cos = Math.cos(angle);\n\n            // Initialize with simple average for first INIT_AVG_COUNT readings\n            if (this.movingAvgCount < this.INIT_AVG_COUNT) {\n                this.movingAvgSin += sin;\n                this.movingAvgCos += cos;\n                this.movingAvgCount++;\n\n                if (this.movingAvgCount === this.INIT_AVG_COUNT) {\n                    this.movingAvgSin /= this.INIT_AVG_COUNT;\n                    this.movingAvgCos /= this.INIT_AVG_COUNT;\n                }\n                return;\n            }\n\n            // Apply exponential moving average\n            this.movingAvgSin = this.movingAvgSin + this.movingAvgAlpha * (sin - this.movingAvgSin);\n            this.movingAvgCos = this.movingAvgCos + this.movingAvgAlpha * (cos - this.movingAvgCos);\n\n            // Calculate angle from sin and cos components\n            let avgAngle = 0;\n            if (this.movingAvgSin < 0) {\n                avgAngle = 2 * Math.PI - Math.acos(this.movingAvgCos);\n            } else {\n                avgAngle = Math.acos(this.movingAvgCos);\n            }\n\n            // Convert back to raw format\n            this.movingAvgAngle = (avgAngle / (2 * Math.PI)) * RESOLUTION;\n        }\n\n        /**\n         * Get the moving average angle in specified unit\n         * @param unit Unit to convert to (U_RAW, U_TRN, U_DEG, U_RAD, U_GRAD)\n         * @returns Moving average angle in specified unit\n         */\n        //% blockId=as5048b_get_moving_avg block=\"%sensor|obtenir moyenne mobile || unité %unit\"\n        //% unit.defl=3\n        //% expandableArgumentMode=\"toggle\"\n        //% weight=10\n        getMovingAvg(unit: number = U_DEG): number {\n            return this.convertAngle(unit, this.movingAvgAngle);\n        }\n    }\n\n    // Export unit constants for external use\n    export const Unit = {\n        RAW: U_RAW,\n        TURN: U_TRN,\n        DEGREES: U_DEG,\n        RADIANS: U_RAD,\n        GRADIANS: U_GRAD\n    };\n}"],[1,"basic.forever(function () {\n\t\n})\n"]],"start1":0,"start2":0,"length1":14503,"length2":33}]}]},{"timestamp":1744409040101,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"block type=\"device_forever\" x=\"20\" y=\"20\"></block><block type=\"function_definition\" x=\"225\" y=\"20\"><mutation name=\"test\" functionid=\"X=9%Fn=zKCpZUSk,q7O4\"></mutation><field name=\"function_name\">test</field></block><"],[0,"/xml>"]],"start1":71,"start2":71,"length1":13,"length2":228}]}]},{"timestamp":1744409106521,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":234,"start2":234,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1744219162029,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-ams_as5048b\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1744409040101,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" x=\"20\" y=\"20\"></block><block type=\"function_definition\" x=\"225\" y=\"20\"><mutation name=\"test\" functionid=\"X=9%Fn=zKCpZUSk,q7O4\"></mutation><field name=\"function_name\">test</field></block></xml>","main.ts":"basic.forever(function () {\n\t\n})\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-ams_as5048b\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1744409106526}