<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id=".tu!D}p8g;8]p7@-vRw6" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="(E5E=z9E;pSo@nPl*sk/"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace AS5048B {" line1="    // Constants for register addresses" line2="    const REG_PROG = 0x03;          // Programming register" line3="    const REG_ADDR = 0x15;          // Address register" line4="    const REG_ZEROMSB = 0x16;       // Zero position MSB register" line5="    const REG_ZEROLSB = 0x17;       // Zero position LSB register" line6="" line7="    const REG_AGC = 0xFA;           // Automatic Gain Control register" line8="    const REG_DIAG = 0xFB;          // Diagnostics register" line9="" line10="    const REG_MAGNMSB = 0xFC;       // Magnitude MSB register" line11="    const REG_MAGNLSB = 0xFD;       // Magnitude LSB register" line12="    const REG_ANGLMSB = 0xFE;       // Angle MSB register" line13="    const REG_ANGLLSB = 0xFF;       // Angle LSB register" line14="" line15="    // Constants" line16="    const RESOLUTION = 16384;       // 2^14, maximum value for angle" line17="" line18="    // Angle unit constants" line19="    const U_RAW = 1;                // Raw sensor value (0-16383)" line20="    const U_TRN = 2;                // Turn (0.0-1.0)" line21="    const U_DEG = 3;                // Degrees (0.0-359.98)" line22="    const U_RAD = 4;                // Radians (0.0-6.28)" line23="    const U_GRAD = 5;               // Gradians (0.0-400.0)" line24="" line25="    /**" line26="     * Structure pour stocker les données et l'état de diagnostic de l'encodeur" line27="     */" line28="    export interface AS5048BData {" line29="        rawAngle: number;      // Angle brut (0-16383)" line30="        angle: number;         // Angle en degrés (0-359.98)" line31="        magnitude: number;     // Magnitude du champ magnétique" line32="        agc: number;           // Valeur de contrôle de gain automatique" line33="        diagnostics: number;   // Valeur du registre de diagnostic" line34="        isValid: boolean;      // Indique si les données sont valides" line35="        errorType: string;     // Type d'erreur si les données ne sont pas valides" line36="    }" line37="" line38="    /**" line39="     * Calculate the I2C address based on a1 and a2 pins" line40="     * Equivalent to: #define AS5048B_ADDR(a1,a2)  (uint8_t)(0x40 | ( !a1 ? 0x2 : 0 ) | ( !a2 ? 0x1 : 0 ))" line41="     * @param a1 Address pin A1 state" line42="     * @param a2 Address pin A2 state" line43="     * @returns Calculated I2C address" line44="     */" line45="    function calculateAddress(a1: boolean, a2: boolean): number {" line46="        return 0x40 | (!a1 ? 0x2 : 0) | (!a2 ? 0x1 : 0);" line47="    }" line48="" line49="    /**" line50="     * Creates a new AS5048B sensor instance" line51="     * @param a1 State of A1 address pin (0 or 1)" line52="     * @param a2 State of A2 address pin (0 or 1)" line53="     */" line54="    //% blockId=as5048b_create_with_pins block=&quot;créer capteur AS5048B avec pins a1 %a1 a2 %a2&quot;" line55="    //% a1.defl=1" line56="    //% a2.defl=1" line57="    //% weight=100" line58="    export function createSensorWithPins(a1: boolean = true, a2: boolean = true): AS5048BSensor {" line59="        const address = calculateAddress(a1, a2);" line60="        return new AS5048BSensor(address);" line61="    }" line62="" line63="    /**" line64="     * Creates a new AS5048B sensor instance" line65="     * @param address I2C address of the sensor (default: 0x40)" line66="     */" line67="    //% blockId=as5048b_create block=&quot;créer capteur AS5048B à l'adresse %address&quot;" line68="    //% address.defl=0x40" line69="    //% weight=99" line70="    export function createSensor(address: number = 0x40): AS5048BSensor {" line71="        return new AS5048BSensor(address);" line72="    }" line73="" line74="    /**" line75="     * Class representing an AS5048B magnetic rotary encoder" line76="     */" line77="    export class AS5048BSensor {" line78="        private i2cAddr: number;" line79="        private clockWise: boolean;" line80="        private lastAngleRaw: number;" line81="" line82="        // Moving average variables" line83="        private movingAvgEnabled: boolean;" line84="        private movingAvgAlpha: number;" line85="        private movingAvgSin: number;" line86="        private movingAvgCos: number;" line87="        private movingAvgAngle: number;" line88="        private movingAvgCount: number;" line89="        private readonly INIT_AVG_COUNT = 5;" line90="" line91="        /**" line92="         * Create a new AS5048B sensor" line93="         * @param address I2C address of the sensor" line94="         */" line95="        constructor(address: number) {" line96="            this.i2cAddr = address;" line97="            this.clockWise = false;" line98="            this.lastAngleRaw = 0;" line99="" line100="            // Initialize moving average variables" line101="            this.movingAvgEnabled = false;" line102="            this.movingAvgAlpha = 0.2;" line103="            this.movingAvgSin = 0;" line104="            this.movingAvgCos = 0;" line105="            this.movingAvgAngle = 0;" line106="            this.movingAvgCount = 0;" line107="        }" line108="" line109="        /**" line110="         * Set the I2C address for this sensor" line111="         * @param address New I2C address" line112="         */" line113="        //% blockId=as5048b_set_address block=&quot;%sensor|définir l'adresse I2C à %address&quot;" line114="        //% weight=90" line115="        setAddress(address: number): void {" line116="            this.i2cAddr = address;" line117="        }" line118="" line119="        /**" line120="         * Set rotation direction (clockwise or counter-clockwise)" line121="         * @param cw true for clockwise, false for counter-clockwise" line122="         */" line123="        //% blockId=as5048b_set_direction block=&quot;%sensor|définir direction %cw&quot;" line124="        //% cw.defl=false" line125="        //% weight=85" line126="        setClockWise(cw: boolean): void {" line127="            this.clockWise = cw;" line128="            this.resetMovingAvg();" line129="        }" line130="" line131="        /**" line132="         * Check if the sensor is connected" line133="         * @returns true if connected, false otherwise" line134="         */" line135="        //% blockId=as5048b_is_connected block=&quot;%sensor|est connecté ?&quot;" line136="        //% weight=80" line137="        isConnected(): boolean {" line138="            try {" line139="                let result = this.getDiagnostic();" line140="                if(result &gt;= 1)" line141="                    return true;" line142="                else" line143="                    return false;" line144="                " line145="            } catch (e) {" line146="                return false;" line147="            }" line148="        }" line149="" line150="        // Méthode de débogage pour comparer 8-bit vs 16-bit" line151="        private debugReadReg8(reg: number): void {" line152="            // Utiliser les deux méthodes et comparer" line153="            let value8 = this.readReg8(reg);" line154="" line155="            // Utiliser readReg16 pour obtenir un octet" line156="            pins.i2cWriteNumber(this.i2cAddr, reg, NumberFormat.UInt8BE);" line157="            let buffer = pins.i2cReadBuffer(this.i2cAddr, 1);" line158="            let value16Method = buffer[0];" line159="" line160="            pins.i2cWriteNumber(this.i2cAddr, reg, NumberFormat.UInt8BE);" line161="            let buffer2 =  pins.i2cReadNumber(this.i2cAddr, NumberFormat.UInt8BE);" line162="" line163="            serial.writeLine(&quot;Reg &quot; + reg + &quot; - readReg8: &quot; + value8 + &quot;, readReg16 method: &quot; + value16Method + &quot;, readReg8BE method: &quot; + buffer2);" line164="        }" line165="" line166="" line167="        /**" line168="         * Read register value (8-bit)" line169="         * @param reg Register address" line170="         * @returns 8-bit register value" line171="         */" line172="        private readReg8(reg: number): number {" line173="            " line174="            try {" line175="                pins.i2cWriteNumber(this.i2cAddr, reg, NumberFormat.UInt8BE);" line176="                return pins.i2cReadNumber(this.i2cAddr, NumberFormat.UInt8LE);" line177="                //let readBuffer = pins.i2cReadBuffer(this.i2cAddr, 1);" line178="                //return readBuffer[0];" line179="            } catch (f) {" line180="                // Gestion d'erreur I2C simplifiée" line181="                serial.writeLine(&quot;readReg8 I2C error: &quot; + f.message);" line182="                return 0;" line183="            }" line184="        }" line185="" line186="        /**" line187="         * Read register value (16-bit)" line188="         * @param reg Register address" line189="         * @returns 14-bit register value (masked appropriately)" line190="        * (7..0 MSB + 5..0 LSB) =&gt; valeur de 14 bits" line191="        */" line192="        private readReg16(reg: number): number {" line193="            // Nombre d'octets à lire" line194="            const nbByte2Read = 2;" line195="            let requestResult: number;" line196="            let readArray: number[] = [0, 0];" line197="            let readValue = 0;" line198="" line199="            // Démarrer la transmission I2C" line200="            pins.i2cWriteNumber(" line201="                this.i2cAddr," line202="                reg," line203="                NumberFormat.UInt8LE," line204="                true  // répéter (équivalent à endTransmission(false))" line205="            );" line206="" line207="            // Vérification d'erreur I2C (simplifiée pour micro:bit)" line208="            try {" line209="                // Lire les données" line210="                let readBuffer = pins.i2cReadBuffer(this.i2cAddr, nbByte2Read);" line211="" line212="                // Convertir le buffer en tableau" line213="                readArray[0] = readBuffer[0];" line214="                readArray[1] = readBuffer[1];" line215="" line216="                // Combiner les deux octets pour obtenir la valeur de 14 bits" line217="                readValue = (readArray[0] &lt;&lt; 6);" line218="                readValue += (readArray[1] &amp; 0x3F);" line219="" line220="                return readValue;" line221="            } catch (g) {" line222="                // Gestion d'erreur I2C simplifiée" line223="                serial.writeLine(&quot;readReg16 I2C error: &quot; + g.message);" line224="                return 0;" line225="            }" line226="        }" line227="" line228="        /**" line229="         * Write register value (8-bit)" line230="         * @param reg Register address" line231="         * @param value Value to write" line232="         */" line233="        private writeReg(reg: number, value: number): void {" line234="            let buffer3 = pins.createBuffer(2);" line235="            buffer3.setUint8(0, reg);     // Adresse du registre" line236="            buffer3.setUint8(1, value);   // Valeur à écrire" line237="            pins.i2cWriteBuffer(this.i2cAddr, buffer3);" line238="        }" line239="" line240="        /**" line241="             * Lit l'angle brut et les informations de diagnostic en une seule requête I2C" line242="             * Lit les registres 0xFA à 0xFF en une seule opération" line243="             * @returns Objet contenant l'angle et les informations de diagnostic" line244="             */" line245="        //% blockId=as5048b_raw_angle_with_diag block=&quot;%sensor|angle brut avec diagnostic&quot;" line246="        //% weight=74" line247="        getRawAngleWithDiag(): AS5048BData {" line248="            try {" line249="                // Commencer la lecture à partir du registre 0xFA (REG_DIAG)" line250="                pins.i2cWriteNumber(this.i2cAddr, REG_DIAG, NumberFormat.UInt8BE);" line251="" line252="                // Lire les 6 octets consécutifs (de 0xFA à 0xFF)" line253="                let buffer4 = pins.i2cReadBuffer(this.i2cAddr, 6);" line254="" line255="                // Extraire les données du buffer" line256="                const agc = buffer4[0];           // REG_AGC (0xFA)" line257="                const diag = buffer4[1];          // REG_DIAG (0xFB)" line258="                const magnMsb = buffer4[2];       // REG_MAGNMSB (0xFC)" line259="                const magnLsb = buffer4[3];       // REG_MAGNLSB (0xFD)" line260="                const angleMsb = buffer4[4];      // REG_ANGLMSB (0xFE)" line261="                const angleLsb = buffer4[5];      // REG_ANGLLSB (0xFF)" line262="" line263="                // Combiner les octets pour obtenir l'angle brut (14 bits)" line264="                let rawAngle = (angleMsb &lt;&lt; 6) + (angleLsb &amp; 0x3F);" line265="" line266="                // Gérer la rotation dans le sens horaire si nécessaire" line267="                if (this.clockWise) {" line268="                    rawAngle = 0x3FFF - rawAngle; // 0x3FFF = 16383 (14 bits à 1)" line269="                }" line270="" line271="                // Combiner les octets pour obtenir la magnitude" line272="                const magnitude = (magnMsb &lt;&lt; 6) + (magnLsb &amp; 0x3F);" line273="" line274="                // Vérifier la validité des données à partir du registre de diagnostic" line275="                let isValid = true;" line276="                let errorType = &quot;&quot;;" line277="" line278="                if ((diag &amp; 0x0001) !== 1) {" line279="                    isValid = false;" line280="                    errorType = &quot;OFFSET COMPENSATION NOT FINISHED&quot;;" line281="                }else if ((diag &amp; 0x0010) !== 0) {" line282="                    isValid = false;" line283="                    errorType = &quot;CORDIC_OVERFLOW&quot;;" line284="                } else if ((diag &amp; 0x0100) !== 0) {" line285="                    isValid = false;" line286="                    errorType = &quot;MAGNET_TOO_WEAK&quot;;" line287="                } else if ((diag &amp; 0x1000) !== 0) {" line288="                    isValid = false;" line289="                    errorType = &quot;MAGNET_TOO_STRONG&quot;;" line290="                }" line291="" line292="                // Calculer l'angle en degrés" line293="                const angleDeg = (rawAngle * 360) / RESOLUTION;" line294="" line295="                // Stocker la valeur brute comme dernière valeur d'angle connue" line296="                this.lastAngleRaw = rawAngle;" line297="" line298="                /*" line299="                //debug" line300="                serial.writeLine(&quot;rawAngle=&quot; + rawAngle);" line301="                serial.writeLine(&quot;agc=&quot; + agc);" line302="                serial.writeLine(&quot;diag=&quot; + diag);" line303="                serial.writeLine(&quot;magnitude=&quot; + magnitude);" line304="                serial.writeLine(&quot;isValid=&quot; + isValid);" line305="                serial.writeLine(&quot;errorType=&quot; + errorType);" line306="                */" line307="                " line308="                // Retourner toutes les données dans un objet" line309="                return {" line310="                    rawAngle: rawAngle," line311="                    angle: angleDeg," line312="                    magnitude: magnitude," line313="                    agc: agc," line314="                    diagnostics: diag," line315="                    isValid: isValid," line316="                    errorType: errorType" line317="                };" line318="            } catch (h) {" line319="                // En cas d'erreur I2C, retourner un objet avec des données invalides" line320="                //TODO en cas d'error prendre la derniere valeur" line321="                serial.writeLine(&quot;Erreur I2C dans getRawAngleWithDiag: &quot; + h.message);" line322="                return {" line323="                    rawAngle: 0," line324="                    angle: 0," line325="                    magnitude: 0," line326="                    agc: 0," line327="                    diagnostics: 0," line328="                    isValid: false," line329="                    errorType: &quot;I2C_ERROR&quot;" line330="                };" line331="            }" line332="        }" line333="" line334="        /**" line335="         * Get the raw angle value (0-16383)" line336="         * @returns Raw angle value (14-bit)" line337="         */" line338="        //% blockId=as5048b_raw_angle block=&quot;%sensor|angle brut&quot;" line339="        //% weight=75" line340="        getRawAngle(): number {" line341="            let rawValue = this.readReg16(REG_ANGLMSB);" line342="" line343="            // Handle clockwise rotation if needed" line344="            if (this.clockWise) {" line345="                // 0b11111111111111 correspond à 16383 en décimal (0x3FFF) (14 bits à 1)" line346="                rawValue = 0x3FFF - rawValue;" line347="            }" line348="" line349="            this.lastAngleRaw = rawValue;" line350="            return rawValue;" line351="        }" line352="" line353="        /**" line354="         * Get the angle in degrees (0-359.98)" line355="         * @returns Angle in degrees" line356="         */" line357="        //% blockId=as5048b_angle_deg block=&quot;%sensor|angle en degrés&quot;" line358="        //% weight=70" line359="        getAngle(): number {" line360="            return this.convertAngle(U_DEG, this.getRawAngle());" line361="        }" line362="" line363="        /**" line364="         * Get the angle in radians (0-6.28)" line365="         * @returns Angle in radians" line366="         */" line367="        //% blockId=as5048b_angle_rad block=&quot;%sensor|angle en radians&quot;" line368="        //% weight=65" line369="        getAngleRad(): number {" line370="            return this.convertAngle(U_RAD, this.getRawAngle());" line371="        }" line372="" line373="        /**" line374="         * Convert raw angle to specified unit" line375="         * @param unit Unit to convert to (U_RAW, U_TRN, U_DEG, U_RAD, U_GRAD)" line376="         * @param angle Raw angle value" line377="         * @returns Converted angle value" line378="         */" line379="        private convertAngle(unit: number, angle: number): number {" line380="            switch (unit) {" line381="                case U_RAW:" line382="                    return angle;" line383="                case U_TRN:" line384="                    return angle / RESOLUTION;" line385="                case U_DEG:" line386="                    return (angle * 360) / RESOLUTION;" line387="                case U_RAD:" line388="                    return (angle * 2 * Math.PI) / RESOLUTION;" line389="                case U_GRAD:" line390="                    return (angle * 400) / RESOLUTION;" line391="                default:" line392="                    return angle;" line393="            }" line394="        }" line395="" line396="        /**" line397="         * Get the Automatic Gain Control value (distance of the magnet)" line398="         * @returns AGC value (0-255)" line399="         */" line400="        //% blockId=as5048b_get_agc block=&quot;%sensor|valeur AGC&quot;" line401="        //% weight=60" line402="        getAgc(): number {" line403="            //this.debugReadReg8(REG_AGC);" line404="            return this.readReg8(REG_DIAG); //TODO INVERSION CAUSE A DEBUGGER" line405="        }" line406="" line407="        /**" line408="         * Program the current position as the zero position" line409="         */" line410="        //% blockId=as5048b_program_zero block=&quot;%sensor|programmer position zéro&quot;" line411="        //% weight=55" line412="        programZeroPosition(): void {" line413="            // First write 0 to zero register" line414="            this.zeroRegisterWrite(0);" line415="            // Then read current angle and set it as zero position" line416="            const newZero = this.readReg16(REG_ANGLMSB);" line417="            this.zeroRegisterWrite(newZero);" line418="        }" line419="" line420="        /**" line421="         * Write value to zero position register" line422="         * @param value Zero position value" line423="         */" line424="        private zeroRegisterWrite(value: number): void {" line425="            this.writeReg(REG_ZEROMSB, (value &gt;&gt; 6) &amp; 0xFF);" line426="            this.writeReg(REG_ZEROLSB, value &amp; 0x3F);" line427="        }" line428="" line429="        /**" line430="         * Read zero position register" line431="         * @returns Zero position value" line432="         */" line433="        //% blockId=as5048b_read_zero_reg block=&quot;%sensor|lire registre zéro&quot;" line434="        //% weight=50" line435="        zeroRegisterRead(): number {" line436="            return this.readReg16(REG_ZEROMSB);" line437="        }" line438="" line439="        /**" line440="         * Get the diagnostic value" line441="         * @returns Diagnostic register value" line442="         */" line443="        //% blockId=as5048b_get_diag block=&quot;%sensor|valeur diagnostic&quot;" line444="        //% weight=45" line445="        getDiagnostic(): number {" line446="            //this.debugReadReg8(REG_DIAG);" line447="            return this.readReg8(REG_AGC);//TODO INVERSION CAUSE A DEBUGGER" line448="        }" line449="" line450="        /**" line451="         * Get the magnitude value of the magnetic field" line452="         * @returns Magnitude value" line453="         */" line454="        //% blockId=as5048b_get_magnitude block=&quot;%sensor|valeur magnitude&quot;" line455="        //% weight=40" line456="        getMagnitude(): number {" line457="            return this.readReg16(REG_MAGNMSB);" line458="        }" line459="" line460="        /**" line461="         * Check if there is a CORDIC overflow error" line462="         * @returns true if CORDIC overflow error is present" line463="         */" line464="        //% blockId=as5048b_diag_cordic block=&quot;%sensor|cordic overflow ?&quot;" line465="        //% weight=35" line466="        hasCordicOverflow(): boolean {" line467="            const diag2 = this.getDiagnostic();" line468="            return (diag2 &amp; 0x0010) !== 0;" line469="        }" line470="" line471="        /**" line472="         * Check if the magnet is too strong" line473="         * @returns true if magnet is too strong" line474="         */" line475="        //% blockId=as5048b_diag_mag_high block=&quot;%sensor|aimant trop fort ?&quot;" line476="        //% weight=30" line477="        isMagnetTooStrong(): boolean {" line478="            const diag3 = this.getDiagnostic();" line479="            return (diag3 &amp; 0x1000) !== 0;" line480="        }" line481="" line482="        /**" line483="         * Check if the magnet is too weak" line484="         * @returns true if magnet is too weak" line485="         */" line486="        //% blockId=as5048b_diag_mag_low block=&quot;%sensor|aimant trop faible ?&quot;" line487="        //% weight=25" line488="        isMagnetTooWeak(): boolean {" line489="            const diag4 = this.getDiagnostic();" line490="            return (diag4 &amp; 0x0100) !== 0;" line491="        }" line492="" line493="        /**" line494="         * Enable exponential moving average filtering" line495="         * @param enable true to enable, false to disable" line496="         * @param alpha Smoothing factor (0.0-1.0)" line497="         */" line498="        //% blockId=as5048b_enable_moving_avg block=&quot;%sensor|activer moyenne mobile %enable || alpha %alpha&quot;" line499="        //% enable.defl=true" line500="        //% alpha.defl=0.2" line501="        //% expandableArgumentMode=&quot;toggle&quot;" line502="        //% weight=20" line503="        enableMovingAvg(enable: boolean, alpha: number = 0.2): void {" line504="            this.movingAvgEnabled = enable;" line505="            this.movingAvgAlpha = alpha &lt; 0 ? 0 : (alpha &gt; 1 ? 1 : alpha);" line506="            this.resetMovingAvg();" line507="        }" line508="" line509="        /**" line510="         * Reset moving average calculations" line511="         */" line512="        private resetMovingAvg(): void {" line513="            this.movingAvgCount = 0;" line514="            this.movingAvgSin = 0;" line515="            this.movingAvgCos = 0;" line516="            this.movingAvgAngle = 0;" line517="        }" line518="" line519="        /**" line520="         * Update the exponential moving average" line521="         * Should be called regularly to maintain accurate averaging" line522="         */" line523="        //% blockId=as5048b_update_moving_avg block=&quot;%sensor|mettre à jour moyenne mobile&quot;" line524="        //% weight=15" line525="        updateMovingAvg(): void {" line526="            if (!this.movingAvgEnabled) return;" line527="" line528="            // Get angle in radians" line529="            const angle = this.getAngleRad();" line530="            const sin = Math.sin(angle);" line531="            const cos = Math.cos(angle);" line532="" line533="            // Initialize with simple average for first INIT_AVG_COUNT readings" line534="            if (this.movingAvgCount &lt; this.INIT_AVG_COUNT) {" line535="                this.movingAvgSin += sin;" line536="                this.movingAvgCos += cos;" line537="                this.movingAvgCount++;" line538="" line539="                if (this.movingAvgCount === this.INIT_AVG_COUNT) {" line540="                    this.movingAvgSin /= this.INIT_AVG_COUNT;" line541="                    this.movingAvgCos /= this.INIT_AVG_COUNT;" line542="                }" line543="                return;" line544="            }" line545="" line546="            // Apply exponential moving average" line547="            this.movingAvgSin = this.movingAvgSin + this.movingAvgAlpha * (sin - this.movingAvgSin);" line548="            this.movingAvgCos = this.movingAvgCos + this.movingAvgAlpha * (cos - this.movingAvgCos);" line549="" line550="            // Calculate angle from sin and cos components" line551="            let avgAngle = 0;" line552="            if (this.movingAvgSin &lt; 0) {" line553="                avgAngle = 2 * Math.PI - Math.acos(this.movingAvgCos);" line554="            } else {" line555="                avgAngle = Math.acos(this.movingAvgCos);" line556="            }" line557="" line558="            // Convert back to raw format" line559="            this.movingAvgAngle = (avgAngle / (2 * Math.PI)) * RESOLUTION;" line560="        }" line561="" line562="        /**" line563="         * Get the moving average angle in specified unit" line564="         * @param unit Unit to convert to (U_RAW, U_TRN, U_DEG, U_RAD, U_GRAD)" line565="         * @returns Moving average angle in specified unit" line566="         */" line567="        //% blockId=as5048b_get_moving_avg block=&quot;%sensor|obtenir moyenne mobile || unité %unit&quot;" line568="        //% unit.defl=3" line569="        //% expandableArgumentMode=&quot;toggle&quot;" line570="        //% weight=10" line571="        getMovingAvg(unit: number = U_DEG): number {" line572="            return this.convertAngle(unit, this.movingAvgAngle);" line573="        }" line574="    }" line575="" line576="    // Export unit constants for external use" line577="    export const Unit = {" line578="        RAW: U_RAW," line579="        TURN: U_TRN," line580="        DEGREES: U_DEG," line581="        RADIANS: U_RAD," line582="        GRADIANS: U_GRAD" line583="    };" line584="" line585="}" numlines="586"></mutation><next><block type="typescript_statement" id="h::sGA}7vZ;4T#_ju,k!"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace MagEncoders {" line1="    /**" line2="     * Creates a new MagEncoder instance for dual AS5048B encoders" line3="     * @param is1EncoderRight If the first encoder is connected to the right wheel" line4="     * @param invertEncoderRight Invert right encoder direction" line5="     * @param invertEncoderLeft Invert left encoder direction" line6="     */" line7="    //% blockId=as5048b_create_magencoders block=&quot;créer encodeurs avec Sensor1=droite %is1EncoderRight|inverser droite %invertRight|inverser gauche %invertLeft|sensor1 A1-A2 %setsensor1_A1 %setsensor1_A2|sensor2 A1-A2 %setsensor2_A1 %setsensor2_A2&quot;" line8="    //% is1EncoderRight.defl=true" line9="    //% invertRight.defl=false" line10="    //% invertLeft.defl=false" line11="    //% setsensor1_A1.defl=true" line12="    //% setsensor1_A2.defl=true" line13="    //% setsensor2_A1.defl=true" line14="    //% setsensor2_A2.defl=false" line15="    //% weight=98" line16="    export function createMagEncoder(" line17="        is1EncoderRight: boolean = true," line18="        invertRight: boolean = false," line19="        invertLeft: boolean = false," line20="        setsensor1_A1: boolean = true," line21="        setsensor1_A2: boolean = true," line22="        setsensor2_A1: boolean = true," line23="        setsensor2_A2: boolean = false" line24="    ): MagEncoders {" line25="        return new MagEncoders(is1EncoderRight, invertRight, invertLeft, setsensor1_A1, setsensor1_A2, setsensor2_A1, setsensor2_A2);" line26="    }" line27="" line28="" line29="    /**" line30="     * Class for managing dual magnetic rotary encoders (AS5048B)" line31="     * Used for differential drive robots with left and right encoders" line32="     */" line33="    //% color=#000000" line34="    //% blockId=as5048b_magencoders_class" line35="    //% block=&quot;encodeurs magnétiques&quot;" line36="    export class MagEncoders {" line37="        private sensor1: AS5048B.AS5048BSensor;" line38="        private sensor2: AS5048B.AS5048BSensor;" line39="        private is1EncoderRight: boolean;" line40="        private invertEncoderR: boolean;" line41="        private invertEncoderL: boolean;" line42="" line43="        private encoder1Previous: number;" line44="        private encoder2Previous: number;" line45="        " line46="        public encoderRSum: number;" line47="        public encoderLSum: number;" line48="" line49="        public deltaEncoderRightFiltered: number;" line50="        public deltaEncoderLeftFiltered: number;" line51="" line52="        /**" line53="         * Constructor for magnetic encoders" line54="         * @param is1EncoderRight If the first encoder is on the right wheel" line55="         * @param invertEncoderRight Invert right encoder direction" line56="         * @param invertEncoderLeft Invert left encoder direction" line57="         */" line58="        constructor(" line59="            is1EncoderRight: boolean = true," line60="            invertEncoderRight: boolean = false," line61="            invertEncoderLeft: boolean = false," line62="            setsensor1_A1: boolean = true," line63="            setsensor1_A2: boolean = true," line64="            setsensor2_A1: boolean = true," line65="            setsensor2_A2: boolean = false" line66="        ) {" line67="            // Configure AS5048B sensors with proper addresses" line68="            // First sensor (A1=1, A2=1) =&gt; Address 0x40" line69="            // Second sensor (A1=0, A2=1) =&gt; Address 0x42" line70="            this.sensor1 = AS5048B.createSensorWithPins(setsensor1_A1, setsensor1_A2);" line71="            this.sensor2 = AS5048B.createSensorWithPins(setsensor2_A1, setsensor2_A2);" line72="" line73="            this.is1EncoderRight = is1EncoderRight;" line74="            this.invertEncoderR = invertEncoderRight;" line75="            this.invertEncoderL = invertEncoderLeft;" line76="" line77="            this.encoder1Previous = 0;" line78="            this.encoder2Previous = 0;" line79="            this.encoderRSum = 0;" line80="            this.encoderLSum = 0;" line81="" line82="            this.deltaEncoderRightFiltered = 0; //right encoder delta values" line83="            this.deltaEncoderLeftFiltered = 0; //left encoder delta values" line84="        }" line85="" line86="        /**" line87="         * Start encoders and initialize counters" line88="         */" line89="        //% blockId=as5048b_magencoders_start block=&quot;%encoders|démarrer&quot;" line90="        //% weight=100" line91="        public start(): void {" line92="            let data1 = this.sensor1.getRawAngleWithDiag();" line93="            if (data1.isValid) {" line94="                this.encoder1Previous = ((data1.rawAngle - 8192.0) * 4.0);" line95="            }" line96="            let data2 = this.sensor2.getRawAngleWithDiag();" line97="            if (data2.isValid) {" line98="                this.encoder2Previous = ((data2.rawAngle - 8192.0) * 4.0);" line99="            }" line100="            " line101="            this.encoderRSum = 0;" line102="            this.encoderLSum = 0;" line103="        }" line104="" line105="        /**" line106="         * Reset encoders and counters" line107="         */" line108="        //% blockId=as5048b_magencoders_stop block=&quot;%encoders|réinitialiser&quot;" line109="        //% weight=95" line110="        public stop(): void {" line111="            this.start(); // Reset values" line112="        }" line113="" line114="" line115="        private toInt16(value: number): number {" line116="            //return (((value | 0) &lt;&lt; 16) &gt;&gt; 16);" line117="            // Garder seulement les 16 bits de poids faible" line118="            let intValue = value &amp; 0xFFFF;" line119="" line120="            // Si le bit 15 est à 1, c'est un nombre négatif" line121="            if (intValue &amp; 0x8000) {" line122="                return intValue - 0x10000; // Soustraire 2^16 pour obtenir la valeur négative correcte" line123="            }" line124="            return intValue;" line125="        }" line126="" line127="        /**" line128="         * Get encoder values (delta movement since last reading)" line129="         * @returns Object with right and left encoder delta values" line130="         */" line131="        //% blockId=as5048b_magencoders_get_values block=&quot;%encoders|lire valeurs&quot;" line132="        //% weight=90" line133="        public getValues(): void {" line134="            let deltaEncoderRight = 0.0;" line135="            let deltaEncoderLeft = 0.0;" line136="" line137="            this.deltaEncoderRightFiltered=0;" line138="            this.deltaEncoderLeftFiltered=0;" line139="" line140="            let data12 = this.sensor1.getRawAngleWithDiag();" line141="            let data22 = this.sensor2.getRawAngleWithDiag();" line142="" line143="            //utilisation du depassement d'un int16" line144="            //[0;16383] -8192 * 4 = [-32768;32764]" line145="            //const encoder1 = (this.sensor1.getRawAngle() - 8192.0) * 4.0;" line146="            //const encoder2 = (this.sensor2.getRawAngle() - 8192.0) * 4.0;" line147="            let encoder1 = 0;" line148="            let encoder2 = 0;" line149="            if (data12.isValid)" line150="            {" line151="                encoder1 = (data12.rawAngle - 8192.0) * 4.0;" line152="            } else {" line153="                // Gérer l'erreur" line154="                serial.writeString(&quot;Error:data1: &quot; + data12.errorType + &quot;\n&quot;);" line155="            }" line156="            if (data22.isValid) {" line157="                encoder2 = (data22.rawAngle - 8192.0) * 4.0;" line158="            } else {" line159="                // Gérer l'erreur" line160="                serial.writeString(&quot;Error:data2: &quot; + data22.errorType + &quot;\n&quot;);" line161="            }" line162="" line163="            //debug" line164="            //serial.writeValue(&quot;getRawAngle1&quot;, this.sensor1.getRawAngle());" line165="            //serial.writeValue(&quot;encoder1&quot;, encoder1);" line166="            " line167="    " line168="" line169="            // Determine deltas based on configuration" line170="            if (this.is1EncoderRight) {" line171="                if (data12.isValid) {" line172="                    deltaEncoderRight = encoder1 - this.encoder1Previous;" line173="                }" line174="                if (data22.isValid) {" line175="                    deltaEncoderLeft = encoder2 - this.encoder2Previous;" line176="                }" line177="            } else {" line178="                if (data22.isValid) {" line179="                    deltaEncoderRight = encoder2 - this.encoder2Previous;" line180="                }" line181="                if (data12.isValid) {" line182="                    deltaEncoderLeft = encoder1 - this.encoder1Previous;" line183="                }" line184="            }" line185="            " line186="            //debug" line187="            //serial.writeValue(&quot;deltaEncoderRight&quot;, deltaEncoderRight);" line188="            " line189="            " line190="            // Invert if necessary" line191="            if (this.invertEncoderR)" line192="                deltaEncoderRight = -deltaEncoderRight;" line193="            if (this.invertEncoderL)" line194="                deltaEncoderLeft = -deltaEncoderLeft;" line195="" line196="            // Convert to normalized values" line197="            //deltaEncoderRight = this.toInt16(Math.floor(deltaEncoderRight)) / 4.0;" line198="            //deltaEncoderLeft = this.toInt16(Math.floor(deltaEncoderLeft)) / 4.0;" line199="            deltaEncoderRight = this.toInt16(deltaEncoderRight) / 4.0;" line200="            deltaEncoderLeft = this.toInt16(deltaEncoderLeft) / 4.0;" line201="" line202="            //debug" line203="            //serial.writeValue(&quot;deltaEncoderRight final&quot;, deltaEncoderRight);" line204="" line205="            // Update sums" line206="            //this.encoderRSum += Math.floor(deltaEncoderRight);" line207="            //this.encoderLSum += Math.floor(deltaEncoderLeft);" line208="            this.encoderRSum += deltaEncoderRight;" line209="            this.encoderLSum += deltaEncoderLeft;" line210="" line211="            // Save previous values" line212="            this.encoder1Previous = encoder1;" line213="            this.encoder2Previous = encoder2;" line214="" line215="            " line216="            this.deltaEncoderRightFiltered=deltaEncoderRight;" line217="            this.deltaEncoderLeftFiltered=deltaEncoderLeft;" line218="            " line219="        }" line220="" line221="        /**" line222="         * Get right encoder value" line223="         */" line224="        //% blockId=as5048b_magencoders_get_right block=&quot;%encoders|valeur delta encodeur droit&quot;" line225="        //% weight=85" line226="        public getDeltaRightValue(): number {" line227="            return this.deltaEncoderRightFiltered;" line228="        }" line229="" line230="        /**" line231="         * Get left encoder value" line232="         */" line233="        //% blockId=as5048b_magencoders_get_left block=&quot;%encoders|valeur delta encodeur gauche&quot;" line234="        //% weight=84" line235="        public getDeltaLeftValue(): number {" line236="            return this.deltaEncoderLeftFiltered;" line237="        }" line238="" line239="        /**" line240="         * Get total right encoder count" line241="         */" line242="        //% blockId=as5048b_magencoders_get_total_right block=&quot;%encoders|compteur total droit&quot;" line243="        //% weight=75" line244="        public getRightTotalCount(): number {" line245="            return this.encoderRSum;" line246="        }" line247="" line248="        /**" line249="         * Get total left encoder count" line250="         */" line251="        //% blockId=as5048b_magencoders_get_total_left block=&quot;%encoders|compteur total gauche&quot;" line252="        //% weight=74" line253="        public getLeftTotalCount(): number {" line254="            return this.encoderLSum;" line255="        }" line256="" line257="        /**" line258="         * Reset total encoder counts" line259="         */" line260="        //% blockId=as5048b_magencoders_reset_total block=&quot;%encoders|réinitialiser compteurs&quot;" line261="        //% weight=70" line262="        public resetTotalCount(): void {" line263="            this.encoderRSum = 0;" line264="            this.encoderLSum = 0;" line265="        }" line266="" line267="        /**" line268="         * Check if both encoders are connected" line269="         */" line270="        //% blockId=as5048b_magencoders_check block=&quot;%encoders|encodeurs connectés ?&quot;" line271="        //% weight=65" line272="        public areEncodersConnected(): boolean {" line273="            return this.sensor1.isConnected() &amp;&amp; this.sensor2.isConnected();" line274="        }" line275="" line276="        /**" line277="         * Check if encoder1 is connected" line278="         */" line279="        //% blockId=as5048b_magencoder1_check block=&quot;%encoders|encodeur1 connecté ?&quot;" line280="        //% weight=66" line281="        public getEncoder1Connected(): boolean {" line282="            return this.sensor1.isConnected();" line283="        }" line284="" line285="        /**" line286="         * Check if encoder2 is connected" line287="         */" line288="        //% blockId=as5048b_magencoder2_check block=&quot;%encoders|encodeur2 connecté ?&quot;" line289="        //% weight=67" line290="        public getEncoder2Connected(): boolean {" line291="            return this.sensor2.isConnected();" line292="        }" line293="    }" line294="}" numlines="295"></mutation><next><block type="typescript_statement" id="1AAbhfAHhU2Z;no!Dt]%"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace odometry {" line1="    // Global variables for position tracking" line2="    export let X = 0;           // X position in mm" line3="    export let Y = 0;           // Y position in mm  " line4="    export let alphaRad = 0;       // Orientation angle in radians" line5="" line6="    // Constants - adjust these based on your robot's specifications" line7="    export let entraxeInMM = 100;  // Distance between wheels in mm" line8="    export let ticksPerMeter = 2000;   // Number of ticks per meter" line9="" line10="    // Variables to store encoder deltas" line11="    let dRight = 0;" line12="    let dLeft = 0;" line13="" line14="    /**" line15="     * Initialize the odometry module with specific parameters" line16="     * @param trackWidth Distance between encoders' wheels in mm" line17="     * @param ticksPerMeter Number of encoder ticks per meter" line18="     */" line19="    //% block=&quot;initialize odometry with trackWidth %trackWidth|mm and %ticksPerMeter|ticks per meter&quot;" line20="    export function initialize(entraxe_mm: number, nbticksPerMeter: number) {" line21="        // Convert trackWidth from mm to ticks" line22="        odometry.entraxeInMM = entraxe_mm ;//* nbticksPerMeter / 1000;" line23="        odometry.ticksPerMeter = nbticksPerMeter;" line24="        X = 0;" line25="        Y = 0;" line26="        alphaRad = 0;" line27="    }" line28="" line29="    /**" line30="     * Reset position and orientation to zero" line31="     */" line32="    //% block=&quot;reset odometry&quot;" line33="    export function reset() {" line34="        X = 0;" line35="        Y = 0;" line36="        alphaRad = 0;" line37="    }" line38="" line39="    /**" line40="     * Set position and orientation to specific values" line41="     * @param x X position in mm" line42="     * @param y Y position in mm" line43="     * @param angle Orientation in radians" line44="     */" line45="    //% block=&quot;set position to x: %x|y: %y|angle: %angle&quot;" line46="    export function setPosition(x: number, y: number, anglerad: number) {" line47="        X = x;" line48="        Y = y;" line49="        alphaRad = anglerad;" line50="    }" line51="" line52="    /**" line53="     * Update odometry with new encoder values" line54="     * @param rightDelta Right encoder delta in ticks" line55="     * @param leftDelta Left encoder delta in ticks" line56="     */" line57="    /*" line58="    //% block=&quot;update with right delta: %rightDelta|left delta: %leftDelta&quot;" line59="    export function update(leftDelta: number, rightDelta: number) {" line60="        dRight = rightDelta;" line61="        dLeft = leftDelta;" line62="" line63="        // Calculate angle and distance variations" line64="        let dAlpha = (dRight - dLeft) / 2;         // Variation of the angle in radians" line65="        let dDelta = (dRight + dLeft) / 2;         // Variation of the forward movement" line66="" line67="        // Convert to radians and update angle" line68="        alphaRad += dAlpha / entraxe_tick;" line69="" line70="        // Keep alpha within [-π, π] range" line71="        while (alphaRad &gt; Math.PI) {" line72="            alphaRad -= 2 * Math.PI;" line73="        }" line74="        while (alphaRad &lt; -Math.PI) {" line75="            alphaRad += 2 * Math.PI;" line76="        }" line77="" line78="        // Calculate position offsets" line79="        let dX = Math.cos(alphaRad) * dDelta;" line80="        let dY = Math.sin(alphaRad) * dDelta;" line81="" line82="        // Update position in mm" line83="        X += dX * 1000 / ticksPerMeter;  // Convert from ticks to mm" line84="        Y += dY * 1000 / ticksPerMeter;  // Convert from ticks to mm" line85="    }*/" line86="" line87="    /**" line88="     * Update odometry with new encoder values in mm" line89="     * @param rightDeltaMm Right encoder delta in mm" line90="     * @param leftDeltaMm Left encoder delta in mm" line91="     */" line92="    //% block=&quot;update with leftDelta: %leftDeltaMm|mm + rightDelta: %rightDeltaMm|mm &quot;" line93="    export function update(leftDeltaMm: number, rightDeltaMm: number) {" line94="        // Calculate distance traveled and angle variation" line95="        let deltaDist = (leftDeltaMm + rightDeltaMm) / 2;" line96="        let diffCount = rightDeltaMm - leftDeltaMm;" line97="        let deltaTheta = diffCount / entraxeInMM; // In radians" line98="" line99="        if (diffCount == 0) {" line100="            // Consider movement as a straight line" line101="            // Update position" line102="            X += deltaDist * Math.cos(alphaRad);" line103="            Y += deltaDist * Math.sin(alphaRad);" line104="        } else {" line105="            // Approximate by considering that the robot follows an arc" line106="            // Calculate the radius of curvature of the circle" line107="            let R = deltaDist / deltaTheta;" line108="" line109="            // Update position" line110="            X += R * (-Math.sin(alphaRad) + Math.sin(alphaRad + deltaTheta));" line111="            Y += R * (Math.cos(alphaRad) - Math.cos(alphaRad + deltaTheta));" line112="" line113="            // Update heading" line114="            alphaRad += deltaTheta;" line115="" line116="            // Limit heading to +/- PI to be able to turn in both directions" line117="            if (alphaRad &gt; Math.PI) {" line118="                alphaRad -= 2 * Math.PI;" line119="            } else if (alphaRad &lt;= -Math.PI) {" line120="                alphaRad += 2 * Math.PI;" line121="            }" line122="        }" line123="    }" line124="" line125="    /**" line126="     * Update odometry with new encoder values in ticks" line127="     * @param rightDeltaTicks Right encoder delta in ticks" line128="     * @param leftDeltaTicks Left encoder delta in ticks" line129="     */" line130="    //% block=&quot;update with leftDelta: %leftDeltaTicks|ticks + rightDelta: %rightDeltaTicks|ticks&quot;" line131="    export function updateFromTicks(leftDeltaTicks: number, rightDeltaTicks: number) {" line132="        // Convert ticks to mm" line133="        let rightDeltaMm = rightDeltaTicks * 1000 / ticksPerMeter;" line134="        let leftDeltaMm = leftDeltaTicks * 1000 / ticksPerMeter;" line135="" line136="        // Call the regular update function" line137="        update(leftDeltaMm, rightDeltaMm);" line138="    }" line139="" line140="    /**" line141="     * Get current X position in float mm" line142="     */" line143="    //% block=&quot;get X position (float mm)&quot;" line144="    export function getX(): number {" line145="        return X;" line146="    }" line147="" line148="    /**" line149="     * Get current X position round in mm" line150="     */" line151="    //% block=&quot;get X position (integer mm)&quot;" line152="    export function getXint(): number {" line153="        return Math.floor(X);" line154="    }" line155="" line156="    /**" line157="     * Get current Y position in float mm" line158="     */" line159="    //% block=&quot;get Y position (float mm)&quot;" line160="    export function getY(): number {" line161="        return Y;" line162="    }" line163="" line164="    /**" line165="     * Get current Y position round in mm" line166="     */" line167="    //% block=&quot;get Y position (integer mm)&quot;" line168="    export function getYint(): number {" line169="        return Math.floor(Y);" line170="    }" line171="" line172="    /**" line173="     * Get current orientation in radians" line174="     */" line175="    //% block=&quot;get orientation (radians)&quot;" line176="    export function getOrientationRad(): number {" line177="        return alphaRad;" line178="    }" line179="" line180="    /**" line181="     * Get current orientation in degrees" line182="     */" line183="    //% block=&quot;get orientation (degrees)&quot;" line184="    export function getOrientationDegrees(): number {" line185="        return alphaRad * 180 / Math.PI;" line186="    }" line187="" line188="    /**" line189="     * Calculate distance to a point" line190="     * @param x X coordinate of the target point" line191="     * @param y Y coordinate of the target point" line192="     */" line193="    //% block=&quot;distance to point x: %x|y: %y&quot;" line194="    export function distanceTo(x: number, y: number): number {" line195="        let dx = x - X;" line196="        let dy = y - Y;" line197="        return Math.sqrt(dx * dx + dy * dy);" line198="    }" line199="" line200="    /**" line201="     * Calculate angle in radians to a point (relative to current orientation)" line202="     * @param x X coordinate of the target point" line203="     * @param y Y coordinate of the target point" line204="     */" line205="    //% block=&quot;angle to point x: %x|y: %y&quot;" line206="    export function angleTo(x: number, y: number): number {" line207="        let dx2 = x - X;" line208="        let dy2 = y - Y;" line209="        let targetAngle = Math.atan2(dy2, dx2);" line210="" line211="        // Calculate the difference and normalize to [-π, π]" line212="        let angleDiff = targetAngle - alphaRad;" line213="        while (angleDiff &gt; Math.PI) {" line214="            angleDiff -= 2 * Math.PI;" line215="        }" line216="        while (angleDiff &lt; -Math.PI) {" line217="            angleDiff += 2 * Math.PI;" line218="        }" line219="" line220="        return angleDiff;" line221="    }" line222="}" numlines="223"></mutation></block></next></block></next></block></statement></block></xml>