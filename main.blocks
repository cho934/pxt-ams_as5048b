<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="R[pGkW)0OgAPlscim^B=" x="20" y="20"><statement name="HANDLER"><block type="typescript_statement" id="EzVSQ:r$GgIyPwtsU#fd"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace AS5048B {" line1="    // Constants for register addresses" line2="    const REG_PROG = 0x03;          // Programming register" line3="    const REG_ADDR = 0x15;          // Address register" line4="    const REG_ZEROMSB = 0x16;       // Zero position MSB register" line5="    const REG_ZEROLSB = 0x17;       // Zero position LSB register" line6="    const REG_AGC = 0xFA;           // Automatic Gain Control register" line7="    const REG_DIAG = 0xFB;          // Diagnostics register" line8="    const REG_MAGNMSB = 0xFC;       // Magnitude MSB register" line9="    const REG_MAGNLSB = 0xFD;       // Magnitude LSB register" line10="    const REG_ANGLMSB = 0xFE;       // Angle MSB register" line11="    const REG_ANGLLSB = 0xFF;       // Angle LSB register" line12="" line13="    // Constants" line14="    const RESOLUTION = 16384;       // 2^14, maximum value for angle" line15="" line16="    // Angle unit constants" line17="    const U_RAW = 1;                // Raw sensor value (0-16383)" line18="    const U_TRN = 2;                // Turn (0.0-1.0)" line19="    const U_DEG = 3;                // Degrees (0.0-359.98)" line20="    const U_RAD = 4;                // Radians (0.0-6.28)" line21="    const U_GRAD = 5;               // Gradians (0.0-400.0)" line22="" line23="    /**" line24="     * Calculate the I2C address based on a1 and a2 pins" line25="     * Equivalent to: #define AS5048B_ADDR(a1,a2)  (uint8_t)(0x40 | ( !a1 ? 0x2 : 0 ) | ( !a2 ? 0x1 : 0 ))" line26="     * @param a1 Address pin A1 state" line27="     * @param a2 Address pin A2 state" line28="     * @returns Calculated I2C address" line29="     */" line30="    function calculateAddress(a1: number, a2: number): number {" line31="        return 0x40 | (!a1 ? 0x2 : 0) | (!a2 ? 0x1 : 0);" line32="    }" line33="" line34="    /**" line35="     * Creates a new AS5048B sensor instance" line36="     * @param a1 State of A1 address pin (0 or 1)" line37="     * @param a2 State of A2 address pin (0 or 1)" line38="     */" line39="    //% blockId=as5048b_create_with_pins block=&quot;créer capteur AS5048B avec pins a1 %a1 a2 %a2&quot;" line40="    //% a1.defl=1" line41="    //% a2.defl=1" line42="    //% weight=100" line43="    export function createSensorWithPins(a1: number = 1, a2: number = 1): AS5048BSensor {" line44="        const address = calculateAddress(a1, a2);" line45="        return new AS5048BSensor(address);" line46="    }" line47="" line48="    /**" line49="     * Creates a new AS5048B sensor instance" line50="     * @param address I2C address of the sensor (default: 0x40)" line51="     */" line52="    //% blockId=as5048b_create block=&quot;créer capteur AS5048B à l'adresse %address&quot;" line53="    //% address.defl=0x40" line54="    //% weight=99" line55="    export function createSensor(address: number = 0x40): AS5048BSensor {" line56="        return new AS5048BSensor(address);" line57="    }" line58="" line59="    /**" line60="     * Class representing an AS5048B magnetic rotary encoder" line61="     */" line62="    export class AS5048BSensor {" line63="        private i2cAddr: number;" line64="        private clockWise: boolean;" line65="        private lastAngleRaw: number;" line66="" line67="        // Moving average variables" line68="        private movingAvgEnabled: boolean;" line69="        private movingAvgAlpha: number;" line70="        private movingAvgSin: number;" line71="        private movingAvgCos: number;" line72="        private movingAvgAngle: number;" line73="        private movingAvgCount: number;" line74="        private readonly INIT_AVG_COUNT = 5;" line75="" line76="        /**" line77="         * Create a new AS5048B sensor" line78="         * @param address I2C address of the sensor" line79="         */" line80="        constructor(address: number) {" line81="            this.i2cAddr = address;" line82="            this.clockWise = false;" line83="            this.lastAngleRaw = 0;" line84="" line85="            // Initialize moving average variables" line86="            this.movingAvgEnabled = false;" line87="            this.movingAvgAlpha = 0.2;" line88="            this.movingAvgSin = 0;" line89="            this.movingAvgCos = 0;" line90="            this.movingAvgAngle = 0;" line91="            this.movingAvgCount = 0;" line92="        }" line93="" line94="        // Rest of the class implementation remains unchanged" line95="" line96="        /**" line97="         * Set the I2C address for this sensor" line98="         * @param address New I2C address" line99="         */" line100="        //% blockId=as5048b_set_address block=&quot;%sensor|définir l'adresse I2C à %address&quot;" line101="        //% weight=90" line102="        setAddress(address: number): void {" line103="            this.i2cAddr = address;" line104="        }" line105="" line106="        /**" line107="         * Set rotation direction (clockwise or counter-clockwise)" line108="         * @param cw true for clockwise, false for counter-clockwise" line109="         */" line110="        //% blockId=as5048b_set_direction block=&quot;%sensor|définir direction %cw&quot;" line111="        //% cw.defl=false" line112="        //% weight=85" line113="        setClockWise(cw: boolean): void {" line114="            this.clockWise = cw;" line115="            this.resetMovingAvg();" line116="        }" line117="" line118="        /**" line119="         * Check if the sensor is connected" line120="         * @returns true if connected, false otherwise" line121="         */" line122="        //% blockId=as5048b_is_connected block=&quot;%sensor|est connecté ?&quot;" line123="        //% weight=80" line124="        isConnected(): boolean {" line125="            try {" line126="                // Read angle register to check connection" line127="                pins.i2cWriteNumber(this.i2cAddr, REG_ANGLMSB, NumberFormat.UInt8BE);" line128="                const result = pins.i2cReadNumber(this.i2cAddr, NumberFormat.UInt16BE);" line129="                return true; // If we get here, communication worked" line130="            } catch (e) {" line131="                return false;" line132="            }" line133="        }" line134="" line135="        /**" line136="         * Read register value (8-bit)" line137="         * @param reg Register address" line138="         * @returns 8-bit register value" line139="         */" line140="        private readReg8(reg: number): number {" line141="            pins.i2cWriteNumber(this.i2cAddr, reg, NumberFormat.UInt8BE);" line142="            return pins.i2cReadNumber(this.i2cAddr, NumberFormat.UInt8BE);" line143="        }" line144="" line145="        /**" line146="         * Read register value (16-bit)" line147="         * @param reg Register address" line148="         * @returns 14-bit register value (masked appropriately)" line149="        * (7..0 MSB + 5..0 LSB) =&gt; valeur de 14 bits" line150="        */" line151="        private readReg16(reg: number): number {" line152="            // Nombre d'octets à lire" line153="            const nbByte2Read = 2;" line154="            let requestResult: number;" line155="            let readArray: number[] = [0, 0];" line156="            let readValue = 0;" line157="" line158="            // Démarrer la transmission I2C" line159="            pins.i2cWriteNumber(" line160="                this.i2cAddr," line161="                reg," line162="                NumberFormat.UInt8LE," line163="                true  // répéter (équivalent à endTransmission(false))" line164="            );" line165="" line166="            // Vérification d'erreur I2C (simplifiée pour micro:bit)" line167="            try {" line168="                // Lire les données" line169="                let readBuffer = pins.i2cReadBuffer(this.i2cAddr, nbByte2Read);" line170="" line171="                // Convertir le buffer en tableau" line172="                readArray[0] = readBuffer[0];" line173="                readArray[1] = readBuffer[1];" line174="" line175="                // Combiner les deux octets pour obtenir la valeur de 14 bits" line176="                readValue = (readArray[0] &lt;&lt; 6);" line177="                readValue += (readArray[1] &amp; 0x3F);" line178="" line179="                return readValue;" line180="            } catch (f) {" line181="                // Gestion d'erreur I2C simplifiée" line182="                serial.writeLine(&quot;readReg16 I2C error&quot;);" line183="                return 0;" line184="            }" line185="        }" line186="" line187="        /**" line188="         * Write register value (8-bit)" line189="         * @param reg Register address" line190="         * @param value Value to write" line191="         */" line192="        private writeReg(reg: number, value: number): void {" line193="            let buffer = pins.createBuffer(2);" line194="            buffer.setUint8(0, reg);     // Adresse du registre" line195="            buffer.setUint8(1, value);   // Valeur à écrire" line196="            pins.i2cWriteBuffer(this.i2cAddr, buffer);" line197="        }" line198="" line199="        /**" line200="         * Get the raw angle value (0-16383)" line201="         * @returns Raw angle value (14-bit)" line202="         */" line203="        //% blockId=as5048b_raw_angle block=&quot;%sensor|angle brut&quot;" line204="        //% weight=75" line205="        getRawAngle(): number {" line206="            let rawValue = this.readReg16(REG_ANGLMSB);" line207="" line208="            // Handle clockwise rotation if needed" line209="            if (this.clockWise) {" line210="                // 0b11111111111111 correspond à 16383 en décimal (0x3FFF) (14 bits à 1)" line211="                rawValue = 0b11111111111111 - rawValue;" line212="            }" line213="" line214="            this.lastAngleRaw = rawValue;" line215="            return rawValue;" line216="        }" line217="" line218="        /**" line219="         * Get the angle in degrees (0-359.98)" line220="         * @returns Angle in degrees" line221="         */" line222="        //% blockId=as5048b_angle_deg block=&quot;%sensor|angle en degrés&quot;" line223="        //% weight=70" line224="        getAngle(): number {" line225="            return this.convertAngle(U_DEG, this.getRawAngle());" line226="        }" line227="" line228="        /**" line229="         * Get the angle in radians (0-6.28)" line230="         * @returns Angle in radians" line231="         */" line232="        //% blockId=as5048b_angle_rad block=&quot;%sensor|angle en radians&quot;" line233="        //% weight=65" line234="        getAngleRad(): number {" line235="            return this.convertAngle(U_RAD, this.getRawAngle());" line236="        }" line237="" line238="        /**" line239="         * Convert raw angle to specified unit" line240="         * @param unit Unit to convert to (U_RAW, U_TRN, U_DEG, U_RAD, U_GRAD)" line241="         * @param angle Raw angle value" line242="         * @returns Converted angle value" line243="         */" line244="        private convertAngle(unit: number, angle: number): number {" line245="            switch (unit) {" line246="                case U_RAW:" line247="                    return angle;" line248="                case U_TRN:" line249="                    return angle / RESOLUTION;" line250="                case U_DEG:" line251="                    return (angle * 360) / RESOLUTION;" line252="                case U_RAD:" line253="                    return (angle * 2 * Math.PI) / RESOLUTION;" line254="                case U_GRAD:" line255="                    return (angle * 400) / RESOLUTION;" line256="                default:" line257="                    return angle;" line258="            }" line259="        }" line260="" line261="        /**" line262="         * Get the Automatic Gain Control value" line263="         * @returns AGC value (0-255)" line264="         */" line265="        //% blockId=as5048b_get_agc block=&quot;%sensor|valeur AGC&quot;" line266="        //% weight=60" line267="        getAgc(): number {" line268="            return this.readReg8(REG_AGC);" line269="        }" line270="" line271="        /**" line272="         * Program the current position as the zero position" line273="         */" line274="        //% blockId=as5048b_program_zero block=&quot;%sensor|programmer position zéro&quot;" line275="        //% weight=55" line276="        programZeroPosition(): void {" line277="            // First write 0 to zero register" line278="            this.zeroRegisterWrite(0);" line279="            // Then read current angle and set it as zero position" line280="            const newZero = this.readReg16(REG_ANGLMSB);" line281="            this.zeroRegisterWrite(newZero);" line282="        }" line283="" line284="        /**" line285="         * Write value to zero position register" line286="         * @param value Zero position value" line287="         */" line288="        private zeroRegisterWrite(value: number): void {" line289="            this.writeReg(REG_ZEROMSB, (value &gt;&gt; 6) &amp; 0xFF);" line290="            this.writeReg(REG_ZEROLSB, value &amp; 0x3F);" line291="        }" line292="" line293="        /**" line294="         * Read zero position register" line295="         * @returns Zero position value" line296="         */" line297="        //% blockId=as5048b_read_zero_reg block=&quot;%sensor|lire registre zéro&quot;" line298="        //% weight=50" line299="        zeroRegisterRead(): number {" line300="            return this.readReg16(REG_ZEROMSB);" line301="        }" line302="" line303="        /**" line304="         * Get the diagnostic value" line305="         * @returns Diagnostic register value" line306="         */" line307="        //% blockId=as5048b_get_diag block=&quot;%sensor|valeur diagnostic&quot;" line308="        //% weight=45" line309="        getDiagnostic(): number {" line310="            return this.readReg8(REG_DIAG);" line311="        }" line312="" line313="        /**" line314="         * Get the magnitude value of the magnetic field" line315="         * @returns Magnitude value" line316="         */" line317="        //% blockId=as5048b_get_magnitude block=&quot;%sensor|valeur magnitude&quot;" line318="        //% weight=40" line319="        getMagnitude(): number {" line320="            return this.readReg16(REG_MAGNMSB);" line321="        }" line322="" line323="        /**" line324="         * Check if there is a CORDIC overflow error" line325="         * @returns true if CORDIC overflow error is present" line326="         */" line327="        //% blockId=as5048b_diag_cordic block=&quot;%sensor|cordic overflow ?&quot;" line328="        //% weight=35" line329="        hasCordicOverflow(): boolean {" line330="            const diag = this.getDiagnostic();" line331="            return (diag &amp; 0x0001) !== 0;" line332="        }" line333="" line334="        /**" line335="         * Check if the magnet is too strong" line336="         * @returns true if magnet is too strong" line337="         */" line338="        //% blockId=as5048b_diag_mag_high block=&quot;%sensor|aimant trop fort ?&quot;" line339="        //% weight=30" line340="        isMagnetTooStrong(): boolean {" line341="            const diag2 = this.getDiagnostic();" line342="            return (diag2 &amp; 0x0008) !== 0;" line343="        }" line344="" line345="        /**" line346="         * Check if the magnet is too weak" line347="         * @returns true if magnet is too weak" line348="         */" line349="        //% blockId=as5048b_diag_mag_low block=&quot;%sensor|aimant trop faible ?&quot;" line350="        //% weight=25" line351="        isMagnetTooWeak(): boolean {" line352="            const diag3 = this.getDiagnostic();" line353="            return (diag3 &amp; 0x0004) !== 0;" line354="        }" line355="" line356="        /**" line357="         * Enable exponential moving average filtering" line358="         * @param enable true to enable, false to disable" line359="         * @param alpha Smoothing factor (0.0-1.0)" line360="         */" line361="        //% blockId=as5048b_enable_moving_avg block=&quot;%sensor|activer moyenne mobile %enable || alpha %alpha&quot;" line362="        //% enable.defl=true" line363="        //% alpha.defl=0.2" line364="        //% expandableArgumentMode=&quot;toggle&quot;" line365="        //% weight=20" line366="        enableMovingAvg(enable: boolean, alpha: number = 0.2): void {" line367="            this.movingAvgEnabled = enable;" line368="            this.movingAvgAlpha = alpha &lt; 0 ? 0 : (alpha &gt; 1 ? 1 : alpha);" line369="            this.resetMovingAvg();" line370="        }" line371="" line372="        /**" line373="         * Reset moving average calculations" line374="         */" line375="        private resetMovingAvg(): void {" line376="            this.movingAvgCount = 0;" line377="            this.movingAvgSin = 0;" line378="            this.movingAvgCos = 0;" line379="            this.movingAvgAngle = 0;" line380="        }" line381="" line382="        /**" line383="         * Update the exponential moving average" line384="         * Should be called regularly to maintain accurate averaging" line385="         */" line386="        //% blockId=as5048b_update_moving_avg block=&quot;%sensor|mettre à jour moyenne mobile&quot;" line387="        //% weight=15" line388="        updateMovingAvg(): void {" line389="            if (!this.movingAvgEnabled) return;" line390="" line391="            // Get angle in radians" line392="            const angle = this.getAngleRad();" line393="            const sin = Math.sin(angle);" line394="            const cos = Math.cos(angle);" line395="" line396="            // Initialize with simple average for first INIT_AVG_COUNT readings" line397="            if (this.movingAvgCount &lt; this.INIT_AVG_COUNT) {" line398="                this.movingAvgSin += sin;" line399="                this.movingAvgCos += cos;" line400="                this.movingAvgCount++;" line401="" line402="                if (this.movingAvgCount === this.INIT_AVG_COUNT) {" line403="                    this.movingAvgSin /= this.INIT_AVG_COUNT;" line404="                    this.movingAvgCos /= this.INIT_AVG_COUNT;" line405="                }" line406="                return;" line407="            }" line408="" line409="            // Apply exponential moving average" line410="            this.movingAvgSin = this.movingAvgSin + this.movingAvgAlpha * (sin - this.movingAvgSin);" line411="            this.movingAvgCos = this.movingAvgCos + this.movingAvgAlpha * (cos - this.movingAvgCos);" line412="" line413="            // Calculate angle from sin and cos components" line414="            let avgAngle = 0;" line415="            if (this.movingAvgSin &lt; 0) {" line416="                avgAngle = 2 * Math.PI - Math.acos(this.movingAvgCos);" line417="            } else {" line418="                avgAngle = Math.acos(this.movingAvgCos);" line419="            }" line420="" line421="            // Convert back to raw format" line422="            this.movingAvgAngle = (avgAngle / (2 * Math.PI)) * RESOLUTION;" line423="        }" line424="" line425="        /**" line426="         * Get the moving average angle in specified unit" line427="         * @param unit Unit to convert to (U_RAW, U_TRN, U_DEG, U_RAD, U_GRAD)" line428="         * @returns Moving average angle in specified unit" line429="         */" line430="        //% blockId=as5048b_get_moving_avg block=&quot;%sensor|obtenir moyenne mobile || unité %unit&quot;" line431="        //% unit.defl=3" line432="        //% expandableArgumentMode=&quot;toggle&quot;" line433="        //% weight=10" line434="        getMovingAvg(unit: number = U_DEG): number {" line435="            return this.convertAngle(unit, this.movingAvgAngle);" line436="        }" line437="    }" line438="" line439="    // Export unit constants for external use" line440="    export const Unit = {" line441="        RAW: U_RAW," line442="        TURN: U_TRN," line443="        DEGREES: U_DEG," line444="        RADIANS: U_RAD," line445="        GRADIANS: U_GRAD" line446="    };" line447="" line448="" line449="    // Classe principale pour les encodeurs magnétiques" line450="    export class MagEncoder {" line451="        private sensor1: AS5048BSensor;" line452="        private sensor2: AS5048BSensor;" line453="  " line454="" line455="        private is1EncoderRight: boolean;" line456="        private invertEncoderR: boolean;" line457="        private invertEncoderL: boolean;" line458="" line459="        private encoder1Previous: number;" line460="        private encoder2Previous: number;" line461="        private encoderRSum: number;" line462="        private encoderLSum: number;" line463="" line464="        /**" line465="         * Constructeur pour les encodeurs magnétiques" line466="         * @param i2cPins Configuration des broches I2C" line467="         * @param is1EncoderRight Si le premier encodeur est à droite" line468="         * @param invertEncoderRight Inversion de l'encodeur droit" line469="         * @param invertEncoderLeft Inversion de l'encodeur gauche" line470="         */" line471="        constructor(" line472="            is1EncoderRight: boolean = true," line473="            invertEncoderRight: boolean = false," line474="            invertEncoderLeft: boolean = false" line475="        ) {" line476="            // Configuration des adresses I2C pour les capteurs AS5048B" line477="            this.sensor1 = createSensorWithPins(1,1);" line478="            //new AS5048BSensor(0x41); // AS5048B_ADDR(1, 1)" line479="            this.sensor2 = createSensorWithPins(0, 1);" line480="            //new AS5048BSensor(0x40); // AS5048B_ADDR(0, 1)" line481="" line482="" line483="            this.is1EncoderRight = is1EncoderRight;" line484="            this.invertEncoderR = invertEncoderRight;" line485="            this.invertEncoderL = invertEncoderLeft;" line486="" line487="            this.encoder1Previous = 0;" line488="            this.encoder2Previous = 0;" line489="            this.encoderRSum = 0;" line490="            this.encoderLSum = 0;" line491="        }" line492="" line493="        /**" line494="         * Démarre les encodeurs" line495="         */" line496="        public start(): void {" line497="            this.encoder1Previous = ((this.sensor1.getRawAngle() - 8192.0) * 4.0);" line498="            this.encoder2Previous = ((this.sensor2.getRawAngle() - 8192.0) * 4.0);" line499="            this.encoderRSum = 0;" line500="            this.encoderLSum = 0;" line501="        }" line502="" line503="        /**" line504="         * Arrête les encodeurs" line505="         */" line506="        public stop(): void {" line507="            this.start(); // Réinitialise les valeurs" line508="        }" line509="" line510="        /**" line511="         * Récupère les valeurs filtrées des encodeurs" line512="         */" line513="        public getValues(): { right: number, left: number } {" line514="            let deltaEncoderRight = 0.0;" line515="            let deltaEncoderLeft = 0.0;" line516="" line517="            // Récupération des valeurs brutes" line518="" line519="            const encoder1 = (this.sensor1.getRawAngle() - 8192.0) * 4.0;" line520="            const encoder2 = (this.sensor2.getRawAngle() - 8192.0) * 4.0;" line521="" line522="            // Détermination des deltas selon la configuration" line523="            if (this.is1EncoderRight) {" line524="                deltaEncoderRight = encoder1 - this.encoder1Previous;" line525="                deltaEncoderLeft = encoder2 - this.encoder2Previous;" line526="            } else {" line527="                deltaEncoderRight = encoder2 - this.encoder2Previous;" line528="                deltaEncoderLeft = encoder1 - this.encoder1Previous;" line529="            }" line530="" line531="            // Inversion si nécessaire" line532="            if (this.invertEncoderR)" line533="                deltaEncoderRight = -deltaEncoderRight;" line534="            if (this.invertEncoderL)" line535="                deltaEncoderLeft = -deltaEncoderLeft;" line536="" line537="            // Conversion en valeurs normalisées" line538="            deltaEncoderRight = (Math.floor(deltaEncoderRight) &amp; 0xFFFF) / 4.0;" line539="            deltaEncoderLeft = (Math.floor(deltaEncoderLeft) &amp; 0xFFFF) / 4.0;" line540="" line541="            // Mise à jour des sommes" line542="            this.encoderRSum += Math.floor(deltaEncoderRight);" line543="            this.encoderLSum += Math.floor(deltaEncoderLeft);" line544="" line545="            // Sauvegarde des valeurs précédentes" line546="            this.encoder1Previous = encoder1;" line547="            this.encoder2Previous = encoder2;" line548="" line549="            return {" line550="                right: deltaEncoderRight," line551="                left: deltaEncoderLeft" line552="            };" line553="        }" line554="" line555="        /**" line556="         * Récupère les compteurs totaux des encodeurs" line557="         */" line558="        public getEncodersTotalCount(): { right: number, left: number } {" line559="            return {" line560="                right: this.encoderRSum," line561="                left: this.encoderLSum" line562="            };" line563="        }" line564="    }" line565="}" numlines="566"></mutation></block></statement></block></xml>